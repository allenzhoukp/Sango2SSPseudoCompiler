v0.2增加功能：
新增了对一维数组的支持。
新增了对goto的支持。
新增了对for循环的支持。

Bug修复和改进：
1. 修复了if语句产生的标签发生重名的问题。
2. 修复了true和false会生成意料之外的值的问题。
3. 生成的文件头将会用一个空行和代码部分分开来。
4. 调整了部分局部变量以降低运行中发生堆栈溢出的可能。现在，产生的代码中，函数参数、for循环的第三部分和数组下标所占的代码段的长度不可超过2048个字节。
5. 编译时不再会出现死循环。至多产生20条错误信息。

Bug预告：
如果调用的一个函数/指令/SYSCALL有返回值，但没有被输入到表达式中，也没有用变量承接，那么这个返回值将留在堆栈中。由于这种调用通常独立成行，影响较为轻微，处理起来也比较麻烦，故不予修复。

三国2 Smart Script 伪代码编译器
（v0.2凑合着用版）

1. 说明
这个编译器用于将C风格伪代码编译成符合三国2脚本格式的asm文件。
源代码随编译器程序一同发布。
编译器程序ss.exe是由源代码Parser.cpp，在MinGW32-GCC 4.9.3-1下，使用C++11标准编译的。
压缩包下的文件有：
ss.exe				编译器本体
Parser.cpp			编译器源码
CONFIG.txt			编译器配置文件
SYSCALL_TABLE.txt 	编译器配置文件
Sol13SpcAtk.cpp 	例子（源文件）
ss.asm				例子（生成文件）
您可能需要一些其它文件（如sg2asm.exe, sg2lib.asm, predefine.inc, magic_inst.txt等）进行下一步工作。您可以到注册网盘(henryshow.ys168.com)下载magic压缩包。您也可以到我的网盘(zkp1997.ys168.com)下载小剧本测试版压缩包，需要的文件在游戏目录下的Script文件夹内。

2. 测试版说明
该编译器尚为测试版本，并未实现三国2脚本的所有功能，且可能尚有bug.
如您发现bug，请及时与作者联系。在百度贴吧 @远帆97 即可，但请不要发私信，那玩意儿不大容易被看到。

3. 使用说明
我将假定使用者具备编程基础，并且掌握至少一门C风格语言（包括但不限于：C, C++, C#, Java, Javascript, Python, Action Script）。
如果您熟悉Pascal或Basic，编写适于该编译器的伪代码可能较为困难。但限于本人精力，暂时不支持Pascal或Basic风格的代码。
(1) 将压缩包内文件，包括ss.exe, SYSCALL_TABLE.txt, CONFIG.txt放到伪代码所在目录下。
(2) 使用ss <filename>进行编译。
    i. 您可以在该目录下新建一个后缀名为.bat的文本文件，文件内输入ss <你的文件名>，（不带尖括号），保存后运行该bat文件。
    ii. 您也可以用命令行直接运行该文件。用cd指令切换到伪代码所在目录，然后输入ss <你的文件名> （不带尖括号），回车运行即可。
(3) 如果编译一切顺利，ss.exe将会在同一目录下生成正常的ss.asm。
(4) 生成的ss.asm遵循可被sg2asm.exe编译为.so文件的格式。
    但，您可能无法直接用sg2asm.exe编译它，这是因为您的代码中可能需要调用magic.asm / system.asm / sg2lib.asm中的部分函数，或者别的您自己已经编写好的函数。
    您可以把生成的代码、字符串定义、函数定义等内容复制到您需要的地方，例如magic.asm / system.asm。
(5) 用sg2asm.exe将您需要编译的.asm文件编译。根据注册的说明，将会生成<文件名>.cds，将其改名为<文件名>.so即可。
(6) .so文件复制到三国2目录下的script文件。您可能还需要在sango.ini中注册这一文件，如果它的名字不是magic.so或system.so的话。

4. 语法结构
基本语法结构绝大部分与C语言相同，但也存在差异。
(1) 所有代码和变量声明都应在函数当中。
(2) 函数格式：
    返回值 function 函数名 (参数1, 参数2, ...) [callsign 调用代码] {
        // 代码...
    }
    例如：
    void function Sol13LongSpcAttack (attacker_soldier, harm) callsign 29013 {
        // code...
    }
    声明了一个名为Sol13LongSpcAttack的函数，无返回值，有两个参数 attacker_soldier, harm，调用代码为29013.
    函数名必须由字母、数字和下划线构成，并且必须以（小写或大写）字母开头。区分大小写。
    编译器不会检查在有返回值的函数中，您是否返回了值。这一点与C语言相同。但反之，如果函数没有返回值，试图返回一个值会报错。
(3) 返回值仅允许两种：void（无返回值） 和 int（有返回值）。
    （理论上，三国2脚本支持多个返回值，也支持字符串和浮点型的返回值。目前因精力有限，编译器暂不支持。不过，目前编译器不会阻止return一个字符串型变量的操作。）
(4) 参数和局部变量没有类型，默认为4字节整型变量。
    暂不支持浮点型变量。
    允许字符串变量，但操作时需谨慎。建议仅用于变量赋值和传递函数参数。切勿用数学和按位运算符操作。
    不允许声明全局变量。如果您确实需要全局变量，请使用GetGlobalVariable/SetGlobalVariable指令。详见(11)。
    变量名和参数名必须由字母、数字和下划线构成，并且必须以（小写或大写）字母开头。区分大小写。
(5) 调用代码即为magic.ini中的SCRIPT代号。
    （当然，该代号除magic.ini外，也可能被exe代码或别的脚本代码引用。）
    您也可以在Things.ini中用!XXXXX来调用它，适用的物件范围取决于您的exe。详见我在百度三国群英2吧的兵种特殊攻击一贴：http://tieba.baidu.com/p/3682361722）
(6) 局部变量用var声明。支持声明时直接赋值。不支持一次声明多个变量。
    例如，以下语法是支持的：
        var soldier = GetScriptLinkedObject();
        var i = 1;
        var k;
    但以下语法是不支持的：
        var i, j, k;
    您可以声明一维数组变量。在声明时，需用显式的整数指明数组的长度。该长度不可是变量、宏定义或参数。数组不支持立即赋值。
    例如，以下语法是支持的：
		var array[10];
	以下语法是不支持的：
		var numbers[3] = {1,2,3};
		var keypoint[MAX_LEN];
		var constant_length_array[3*8];
		var dynamic_length_array[variable];
    变量作用域为整个函数。即便您在某个if或while的大括号内声明了变量，它在大括号外仍然有效。
	在代码中，将函数的参数视同局部变量赋值是允许的。
(7) 支持的运算符包括：
        i.   算数运算符 +,-,*,/,%(求余数),-(取负)
        ii.  按位运算符 <<(左移), >>(逻辑右移), &(按位与), |(按位或), ^(异或), ~(取反)
        iii. 比较运算符 ==, !=, <, <=, >, >=
        iv.  逻辑运算符 !(非)
    部分支持的运算符包括：
        i.   逻辑运算符 &&, ||
            （两侧的表达式都一定会被运算。即，a&&b, 即便a已经为假，b的值也会求出来。）
        ii.  赋值运算符 =, +=, -=, *=, /=, %=, &=, |=, <<=, >>=, ^=
            （赋值运算不会返回一个值。if(a = b)这样的写法暂时不被支持，尽管您可能真的想把b赋值给a，并且在b非零时执行条件分支。）
            （赋值运算的左值只能为局部变量、参数或局部数组的某一格。）
    不支持的运算符包括：
        i.  自增自减运算符 ++, -- （++i和i++都不受支持。）
        ii. 取值、取引用运算符 *, &, ->
             （您需要调用 GetData_NotAligned 和 SetData_NotAligned 等函数来完成类似的功能。）
(8) 支持的分支结构包括：
        if...else if...else
        while
        do...while
        for
        goto
    暂不支持：
        switch
    在for循环的第一部分声明变量是被允许的。同样地，该变量的作用域是整个函数。
    编译器不会检查您定义的标签是否重名。编译器不会改变您定义的标签的名字，因此，尤其是您打算把生成的代码复制到别的asm文件中时，需尤其注意这一点。
        （您的确可以强行goto到另一个函数当中，尽管由于这可能导致RETN指令导致的堆栈混乱，我们强烈不推荐您这么做。）
(9) 支持部分系统调用。您可以在SYSCALL_TABLE.txt中找到支持的系统调用，它们是在magic.asm和system.asm中出现过的调用。
    SYSCALL_TABLE.txt每行由4部分组成，从左到右分别是编号、参数个数、返回值类型(0-无，1-整型，3-字符串)、函数名。
    例如：
        0x10 5 1 CreateObjectRaw
    声明了一个编号为0x10，有5个参数，有整型返回值，名字为CreateObjectRaw的函数。
    尽管通常而言您不能增加SYSCALL（它需要在exe中实现），但您可以把现有的、但表中没有的SYSCALL加入到表中。
        （所有已知的SYSCALL可参见注册的magic_inst.txt文件。您可以在注册网盘中下载到，它和sg2asm.exe在同一个压缩包里。）
    另外，由于显而易见的原因，许多SYSCALL其实没有正式名称。因此您还可以更改列表中函数名。这只会影响您的伪代码，而不会影响它的功能。
(10) 支持同时运行多个函数（即异步调用）。当您以asynccall方式调用函数时，它会和接下来的代码一起执行。
     （它的另一个比较熟悉的名字是CALLBS，但我觉得Call by String并不能揭示这种函数调用方法的本质。）
     语法：
         asynccall 函数名(参数);
     例如：
         asynccall Sol13LongSpcSmokeFade(smoke);
     以此法调用的函数返回值没有意义，毕竟调用的函数还没运行完，您的程序就执行到下一行了。
     因此，您必须使它单独成一行，而不能包括在一个表达式里。
     例如，下面的写法是不受支持的：
         var return_value = asynccall GetValue();
     用此法调用的函数至多有9个参数。
(11) 支持以下系统指令：
     i.  全局变量操作（全局变量用编号表示；注意，系统已经使用了不少的全局变量，当心冲突。）
         GetGlobalVariable(index)         INST_09
         SetGlobalVariable(value, index)  SETARG
     ii. INTV操作（很抱歉我不知道注册用这四个字母代表什么含义，但您可以用它取得许多信息，如场上的攻击、防守方武将等。详见注册的predefine.inc。）
         GetINV(index)                    PUSHINV
         SetINV(value, index)             SETINV
     iii. 其它（Delay：使程序暂停一段时间；Wait：等待某个正在运行的函数调用完毕后程序再继续）
         Delay(time)                      DELAY
         Wait(Function Name)              INST_45
     您可以像调用函数一样正常地调用它们，并且可以在表达式中包括它们。
     例如：
         var attackerMajor = GetINV(INTV_ATTACKER_MAJOR);
     需注意的是，全局变量操作和INTV操作中的index都必须是常量。这是由于以上四个指令本身不支持间接寻址。尚未支持间接寻址的指令。
(12) 如果在正常的函数调用中，编译器发现未定义过的函数名（即，不是已经声明过的函数，不在支持的指令中，也未在SYSCALL_TABLE中定义），那么编译器将把它视作已经定义过的普通函数。
     如果是以异步调用方式调用一个未定义的函数，那么编译器将会报错。
     您不可以以异步调用方式调用系统调用(SYSCALL)或系统指令。这是脚本语言本身所不允许的。
(13) 如果编译器发现未定义过的变量/常量名，它会视同一个常数处理，将它直接写入asm文件。
	 这是因为这个常量可能在predefine.inc或别的地方定义过。
	 例如：var attackerMajor = GetINV(INTV_ATTACKER_MAJOR);一句中，INTV_ATTACKER_MAJOR会被视作一个数。
(14) 您可以用 // 来定义单行注释。暂不支持以 /* */ 定义的多行注释。
(15) 暂不支持宏定义。宏定义被视同注释处理。
(16) 暂不支持对全局变量、INTV的间接寻址（数组）操作。您可能仍然需要用直接编写asm代码的形式完成这些功能。

5. 编译
您可能会发现您的代码出现编译错误。这可能是因为您的代码中存在问题或编译器不支持的语法结构，也可能是编译器出错。
如果您怀疑是bug所致，请及时与我联系。
如果您发现编译器不停地报出若干个相同的错误，请忽略那些相同的错误。编译器没有被设计为可以自动跳出因编译出错导致的死循环。
另外，您也可能发现编译器没有对您的代码错误作出反应。作为一个简易编译器，它不进行类型检查、空指针等一些可能导致运行时出错的问题。

6. 编号
如果您需要把生成的代码复制到magic.asm / system.asm中，您一定不希望字符串编号和函数编号从0开始。
因此，您可以在CONFIG.ini中改变这两个起始编号。
目前，这两个编号被设置成原版magic.asm的最后一个字符串编号(函数编号) + 1.

7. 字符串表(string_table)
字符串表将会从0开始生成，直至您自定义的最后一个字符串。您可以直接用这部分内容覆盖掉magic.asm / system.asm的对应位置。

8. 遇到不支持的语法特性？__asm{}来帮您！
您可以直接在伪代码中编写asm格式的脚本。脚本应当用__asm{}括起来。
如果您需要压入一个局部变量或参数，您可以用PUSHARG <变量名>的方式。但请不要直接PUSH <变量名>.
如果您被迫以asm形式书写CALLBS，很遗憾，暂时不支持以"函数名"的形式压入。您仍然需要使用PUSHSTR+数字的方式，并且如果您需要调用的函数是一个您在伪代码中定义的函数，您可能需要用某些别的办法来取得该函数对应的字符串编号。

9. 运行
显然，您需要将生成的asm文件通过任何方式编译为.so文件才能运行。本编译器只能生成中间代码（即类汇编的asm格式）。
如果您需要调试，在C伪代码的基础上进行的调试将是困难的。目前最常见的调试器是注册EXE（您可以在注册网盘上找到v0.522版本的），而它是基于asm格式的代码的。因而您可能仍然需要一些三国2脚本的知识。对此我只能表示遗憾，因精力有限，无法解决这个问题。

10. 鸣谢和声明
编译器代码是在 Sam Nipps 编写的 mini-c 程序上改编而成的。感谢 Sam Nipps 的工作。(github: https://github.com/Fedjmike/mini-c)
源代码在MIT License下开放，详见LICENSE.


远帆
2017/5/3
