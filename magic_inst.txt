;远帆：这个文件是注册写的，原文未做改动，凡分号后面的内容都是我自己的注释，不能代表注册原意。

架构： 
     无寄存器，只有stack的CPU.
     每个stack占位 8byte.
     前4byte = 值
     后4byte = 值类型 (已知 0-数值型   2-字符串型,值表示字符串的地址)
     
     每条指令执行结果为1表示继续执行。
     为0表示中断执行，返回系统。
          助记符	返回值	参数1	参数2	含义
Inst_00 : NOP		1		--		--		空操作
	; 编译器不认，会报错。反汇编出来的东西不删掉NOP编译不了。

Inst_01 : 									
	指令流程：
	1. 读下一个DWORD(参数)	arg_0
	2. 弹出栈顶	var_0
	3. ...
	; 猜想：似乎是以栈顶为返回值的RETN。参数1的值为函数的参数总量。
	; 例如，某函数3参数1返回值，在返回前压入返回值，然后INST_01 3。
	; 目前一般用RETN(即INST_02)实现。如果用RETN实现，在上面的例子中，应将返回值POPN -4, 然后RETN 2。
	; 此指令的具体作用待证实。
	
Inst_02 ：RETN		1		n		--		函数返回，栈底n个为预置参数，无需释放。
	; 弹掉n个之前压入的参数。可以留下若干个作为返回值。
	; 例如，某函数3参数1返回值，结尾应是RETN 2，返回值应放在栈底的arg -4中。

Inst_03 : INCS		1		n		--		堆栈增长n个值
	; 助记符是STACK

Inst_04	: CALL		1		addr	--		调用addr的子程序 
	指令流程：
	1. PUSH RetAddr
	2. PUSH nStackCount
	3. JMP addr

Inst_05 : ICALL		1		Index	un1		调用内部函数，函数索引和含义参见system call。
	; 助记符是SYSCALL

Inst_06 : PUSH		1		para1	--		将para1压栈

Inst_07 : PUSHS		1		index	--		将script中的第index个字符串压栈
	; 助记符是PUSHSTR

Inst_08 : PUSHARG	1		n		--		以当前运行上下文的基本堆栈值为中心，压入第n个参数
    注意：
        当n = 0时，为当前上下文的第一个变量
        当n > 0时，为当前上下文的第n+1个变量
        当n < 0时，为当前上下文的第n个参数
        
Inst_09 : INST_09	1		n		--		压入第n个全局变量(?Top_Stack)

Inst_0A : IPUSH		1		n		--		将内部数组(地址0x4A6878)的第n个数值压栈
	; 助记符是PUSHINV

Inst_0B : POP1		1		n		--		将栈顶的参数弹栈，并移动到第n个变量。 0值为当前栈顶，1为栈顶-1，依次类推。
	; 助记符是POPN

Inst_0C : POP2		1		n		--		[可能] 将栈顶的参数弹栈，并放到第n个参数。 同Inst_08的中心点
	; 并不是。按照对sg2asm.exe的反汇编结果，该指令应为SETARG（设置全局变量）。
	; 即，将栈顶值赋值给指定的全局变量。
	; 例： PUSH 1 SETARG 9 表示令第9个全局变量的值为1.

Inst_0D : ISET		1		n		--		将内部数组(地址0x4A6878)的第n个参数设为栈顶的值。
	; 助记符是SETINV
	指令流程：
	1. ReadNextDword	--> i
	2. PopStack		-->value
	3. InternalArray[i] = value.
	

Inst_0E : POP		1		--		--		栈顶值弹栈并丢弃

Inst_0F : ADD		1		--		--		弹出栈顶2个参数相加并压栈。
	指令流程：
	1. PopStack		--> a1
	2. PopStack		--> a2
	3. Push (a1+a2)

Inst_10 : ADDF		1		--		--		弹出栈顶2个参数(浮点数)相加并压栈
	指令流程：
	1. PopStack		--> f1 : float
	2. PopStack		--> f2 : float
	3. Push (f1+f2)
	
Inst_11 : 
	; 助记符是ADDS。（猜测：字符串连接？）

Inst_12 : SUB		1		--		--		栈顶2数相减并压栈  (整数)
	指令流程：
	1. PopStack		--> a1
	2. PopStack		--> a2
	3. Push (a1-a2)
	;总之是先PUSH的减去后PUSH的就对了。PUSH 3   PUSH 2   SUB得到的是1. 除法和取模（求余）同理。
	
Inst_13 : SUBF		1		--		--		栈顶2数相减并压栈  (浮点数)

Inst_14 : MUL		1		--		--		栈顶2数相乘并压栈  (整数)
	指令流程：
	1. PopStack		--> a1
	2. PopStack		--> a2
	3. Push (a1*a2)
Inst_15 : MULF		1		--		--		栈顶2数相乘并压栈  (浮点数)

Inst_16 : DIV		1		--		--		栈顶2数相除并压栈  (整数)
	指令流程：
	1. PopStack		--> a1
	2. PopStack		--> a2
	3. Push (a1/a2)
Inst_17 : DIVF		1		--		--		栈顶2数相除并压栈  (浮点数)

Inst_18 : MOD		1		--		--		栈顶2数相除并将余数压栈  (整数)
	指令流程：
	1. PopStack		--> a1
	2. PopStack		--> a2
	3. Push (a1%a2)
	
Inst_19 : OP_19		1		--		--		栈顶2数出栈，并将0压栈 (整数)
	; 助记符为NOP19. 我怀疑这条指令到底出现过没有。

Inst_1A : NEG		1		--		--		栈顶参数改变符号 (整数)  (注意：取反+1)

Inst_1B : NEGF		1		--		--		栈顶参数改变符号 (浮点数) 

Inst_1C : NOT		1		--		--		栈顶参数取反

Inst_1D : INC		1		n		--		当前函数堆栈的倒数第n个参数++。	n = 1时为栈顶
	; 助记符为INCN.

Inst_1E : INC		1		n		--		上层函数堆栈的第n个参数++。	(参照Inst_08) ?
	; 助记符为INCARG. （大概指的是全局变量。上层函数是啥？）

Inst_1F : IINC		1		n		--		内部数组的第n个值++
	; 助记符为INCINV.

Inst_20 : DEC		1		n		--		当前函数堆栈的倒数第n个参数++。	n = 1时为栈顶
	; 助记符为DECN.

Inst_21 : DEC		1		n		--		上层函数堆栈的第n个参数--。
	; 助记符为DECARG. 类同INCARG.

Inst_22 : IDEC		1		n		--		内部数组的第n个值--
	; 助记符为DECINV. 类同INCINV.

Inst_23 : AND		1		--		--		栈顶2数相与并压栈

Inst_24 : OR		1		--		--		栈顶2数相或并压栈

Inst_25 : XOR		1		--		--		栈顶2数异或并压栈

Inst_26 : CMP		1		--		--		栈顶2数相等则将1压栈，否则将0压栈

Inst_27 : CMP		1		--		--		栈顶2数相等则将1压栈，否则将0压栈  -- exe如此
	; 助记符为CMPF

Inst_28 : 
	; 助记符为CMPS。含义大概等于strcmp(str1, str2) == 0？idb里复杂到一定境界了。

Inst_29 : CMPZ		1		--		--		栈顶2数相等则将0压栈，否则将1压栈

Inst_2A : CMPZ		1		--		--		栈顶2数相等则将0压栈，否则将1压栈
	; 助记符为CMPZF

Inst_2B :
	; 助记符为CMPZS

Inst_2C : CMPG		1		--		--		栈顶 > 栈顶-1 则将1压栈，否则将0压栈
	; 都是先压的和后压的比较。如，PUSH 1   PUSH 0   CMPG将得到1. 下面的几个比较指令同理。

Inst_2D : CMPGF		1		--		--		栈顶 > 栈顶-1 则将1压栈，否则将0压栈 (浮点数)
	
Inst_2E : 
	; 助记符为CMPGS

Inst_2F : CMPGE		1		--		--		栈顶 >= 栈顶-1 则将1压栈，否则将0压栈

Inst_30 : CMPGEF	1		--		--		栈顶 >= 栈顶-1 则将1压栈，否则将0压栈 (浮点数)

Inst_31 : 
	; 助记符为CMPGEFS (??? 注册你认真的？)
	
Inst_32 : CMPL		1		--		--		栈顶 < 栈顶-1 则将1压栈，否则将0压栈

Inst_33 : CMPLF		1		--		--		栈顶 < 栈顶-1 则将1压栈，否则将0压栈 (浮点数)

Inst_34 : 
	; 助记符为CMPLS
Inst_35 : CMPLE		1		--		--		栈顶 <= 栈顶-1 则将1压栈，否则将0压栈

Inst_36 : CMPLEF	1		--		--		栈顶 <= 栈顶-1 则将1压栈，否则将0压栈 (浮点数)

Inst_37 : 
	; 助记符为CMPLEFS (???)
	
Inst_38 : CMPZ		1		--		--		栈顶为0时，则将1压栈，否则将0压栈
	; 助记符为ZERO。 按照注册所说的语义，应该等同于逻辑非 !
	
Inst_39 : CMPZ2		1		--		--		栈顶 or 栈顶-1为0时，则将0压栈，否则将1压栈
	; 助记符为ORNZ.  按照注册所说的语义，应该等同于逻辑与 &&

Inst_3A : CMPNZ2	1		--		--		栈顶 or 栈顶-1为0时，则将1压栈，否则将0压栈
	; 助记符为ORZ.   注册的说法错误，应该等同于逻辑或 ||
	; 参见idb的SF_3A函数，非常清晰。

Inst_3B : JMP		1		addr	--		无条件跳转到addr.

Inst_3C : JNZ		1		addr	--		栈顶值不为0时，跳转到addr.

Inst_3D : JZ		1		addr	--		栈顶值为0时，跳转到addr
	; 和汇编不同的是，两数相等跳转的话，CMP会得到1，要用JNZ。

Inst_3E : SHL		1		--		--		(栈顶-1) << 栈顶  压栈。

Inst_3F : SAR		1		--		--		(栈顶-1) >> 栈顶  压栈。
	; 尽管注册在sg2asm.exe中用了SHR作助记符，但该指令实际上是SAR，即算术右移。

Inst_40 : JCOND		1		n		addr	栈顶值=n时，跳转到addr
	; 不会弹栈，可以一路JCOND下去，标准的switch脸。记得所有JCOND结束之后要POP下。
	; 可以参考奥汀在SYSTEM.ASM里面是怎么写的。

Inst_41 : NOP
	; 助记符为NOP41. 它确实是NOP. 下面的Inst_43/44相同。

Inst_42 : BUSY		?		n		--		当系统忙时等待n Tick之后继续？   (系统忙时返回0 : 返回到系统，否则返回1 : 继续执行)
	; 助记符为DELAY. 用法如：PUSH 10   DELAY

Inst_43 : NOP

Inst_44 : NOP

Inst_45 : 
	; 非常常见的一个指令。此指令会阻断当前函数执行，直到所指定的函数执行完毕才继续执行。

Inst_46 : 

Inst_47 : CALLBS	1		n		--      Call Subscript by String
	; 第一个先压入要调用的函数的字符串编号，然后按常规调用函数的顺序压入参数（同CALL）。
	; 如果不够四个参数，用0补足。如果多于四个参数，应该用后面的SYSCALL 0x310 - 0x314来代替。
	; CALLBS调用的函数会与原函数并行执行，互相不干扰，有点像多线程。

Inst_48 : ITOF		1		--		--		栈顶的整形值变为浮点数。
	; 助记符为LTOF.

Inst_49 :

Inst_4A : FTOL		1		--		--		栈顶的浮点数变为整数

Inst_4C : POP3		1		--		--		栈顶的值弹栈，并将0压栈
	; 助记符无效，用INST_4C.

Inst_4E : GETVAR_V	1		n		--		局部变量[n+param1]压栈 // 间接寻址
	；助记符是PUSHNR

Inst_4F : INST_4F	1		n		--		全局变量(?Top_Stack)[n+param1]压栈 // 间接寻址

Inst_50 : IGETN		1		n		--		内部数组的第 (栈顶值 + n)个值压栈
	; 助记符是PUSHINVR

Inst_51 : SETVAR_V  	1       	n       	--      	局部变量[n+param2] = param1   // 间接寻址
	；助记符是SETNR
	；用法似乎是先PUSH值，再PUSH param2，然后SETNR N (ARG[N+param2]= value

Inst_52 : INST_52	1		n		--		全局变量(?Top_Stack)[n+param2] = param1 // 间接寻址

Inst_53 : ISETN		1		n		--		栈顶值写入 INTV[栈顶-1+n]
	; 从INST_4E到INST_53, 作用类似于数组操作，数组下标总不会都是静态的，动态的时候就用到这几个了。
	; 比如，要操作第[5 + 循环变量argX]个变量时，就会用到INST_4E和INST_51.
	; 不记得助记符有没有用了，实在编译不过就写INST_XX就好。

Inst_20 = (var_last -= para1)

Inst26 = var_last == var_last-1 结果压栈 (先弹出2个参数，再压入一个参数)(相等为1，否则为0)
Inst26 = var_last != var_last-1 结果压栈 (先弹出2个参数，再压入一个参数)(相等为0，否则为1)
JMP2(INST_3D) = var_last弹栈，如果var_last为0则跳转到参数，否则继续下一条。

Inst2C = var_last < var_last-1 结果压栈 (先弹出2个参数，再压入一个参数) (小于为1，否则为0)


Inst_3A : pop var_last, pop var_last-1;
          if (var_last != 0) push 1
          else if (var_last-1 != 0) push 1
          else push 0
        : push (var_last | var_last-1 != 0)


calls 12F, 1   调用系统函数，设置Brightness。(使用1个参数)


;压栈还是比较容易搞昏头。CALLBS和CALL时，先压入的在最底下，后压入的在上面。例如，3个参数的话，最先压的是-4，最后压的是-2.
;而SYSCALL直接按照括号里面的顺序压栈。先压的就是第一个参数（ebp+8）。两个刚好反过来。


系统调用：
1 : 调用给定dwScriptIndex的脚本函数 
2 : 显示对话框1 (nDir, pGeneral, szPrompt)
3 : 显示对话框2 -- 增强型？ (nDir, pGeneral, szPrompt)
4 ：显示对话框3 - 指定头像文件(nDir, szHeaderShape, szPrompt)
5 ：显示对话框4 - 指定头像文件 增强型(nDir, szHeaderShape, szPrompt)
6 ：;这是用来设置对话框中%SX%替换为什么字符串的函数。(?, X, str) 一般配合SYSCALL 0x200（GetGeneralName）使用。
7 : 批量LoadShape (所有文件名通配string的文件)
8 ：设置当前脚本所链接的物件句柄 
9 ：显示对话框5 - 指定显示位置、主将、以及消息在message.ini中的序号 (nDir, pGeneral, nMessageIndex)
A ：显示对话框6 - 指定显示位置、主将、以及消息在message.ini中的序号  增强型 (nDir, pGeneral, nMessageIndex)
B : GetScriptLinkedObjectHandle
10 : CreateObjectRaw       创建物件，指定X/Y/Angle/Flag/dwSequence
11 : CreateObjectBelongTo  创建属于某个物件的子物件 ;(pObjectHandle, dwSequence, dwFlags, dwAngleOffset)
12 : IsObjectExist
13 : FreeObjectByHandle
14 ：设置物件坐标 (dwHandle, x, y, angle)
15 ：根据物件2的坐标设置物件1的坐标。 MoveObjectByReference(dwHandle1, dwHandle2, nStepAngle, nRadius, nStartAngle) ; 后三个是标志相对位置的。参数是方向(=nStepAngle + nStartAngle)、到中心的距离(nRadius)。
16,17 : 坐标系转换 -- 未全明
;17 : SetObjectStep ( , , ) ; 注册在sg2dbg里面的注释同下，3个参数，未明确。
18 : SetObjectCoordinate_ByVector(hObject, nAngle_Y_XZ, nAngle_Z_XY, nVectorLength)  ;前一个参数是水平面上的角度，0为正右，128为正左。 后一个参数目测是竖直面上的角度。
;19 : MoveObjectTo(dwHandle1, dwHandle2, nStep)
1A : GetObjectDir
;1B : SetObjectProperty(field_5C, field_60) ;似乎是XScale与YScale。 （以下根据field_60）32768时为1/2，0与65536为1，98304为3/2，131072为2，中间类推。
;1C : SetObjectProperty(pDrawingFileItem)
;1D : SetObjectProperty(field_24)
;1E : SetObjectProperty(dwHandle, isGravity) 0 set nogravity 1 clr nogravity
;1F : SetObjectProperty(nLife)
;20 : SetObjectProperty(field_20) <<=0x10 before setting.
;21 : SetObjectProperty(field_20)
23 : CreateObject_Shadow(1012)
24 : CreateObject_Shadow(1012)  与23类似，多一个参数
25 : 设置物件方向 (左右)
26 : SetObjectBrightness 移动物件shadow?
27 : 设置物件亮度 ;StepShow里用此函数，应当较常用。
28 : Offset物件 (cx, cy, cangle, cContext?) ;只有三个参数，把物件的此三个属性+=对应的值。
29 : 设置物件flag (set bit)
2A : 设置物件flag (直接set)
2B : 清除物件flag (clear bit)
2C : 设置callback sequence.
2D : 获得物件的sequence. (在things.ini中的sequence)
2E : 设置callback context  ( i , value)
2F : 获得callback context  ( i , value)
;30 : SetObjectProperty(nDir)
;31 : SetObjectProperty(field_66) WORD.
100 : 设置视角位置 X/Y
102 : 获得物件位置 X/Y (地址)
103 : BattleXToScreenX
104 : BattleYToScreenY
105 : GetMajorScreenX
106 : GetMajorScreenY
;107 : GetObjectAngle? (>>= 0x10)
108 : 屏幕坐标X转换为战场坐标X
109 : ScreenYToBattleY
10C : GetSoldierCount(bRight)
10D : 获得随机的活着士兵的hObject(bRight)
;10E : 将物件2的OBJECT设置为物件1的field_88.
;10F : 将摄像机移到((x+arg1) >> 0x10, (y+arg2) >>0x10)处。
110 : Clear4A6660 -- 允许敌方施放武将技
;111 : GetCameraX
;112 : GetCameraY
113 : 得到指定战场xy坐标处的士兵pObject的field_44的值  -- GetSoldierHandleByXY
;114 : (未见使用，似乎是弹出菜单？)
115 : 得到pObject的所属军队，0 = right, 1 = left, -1 = unknown or none.
116 : 得到主将的等级(bRight)
117 : 得到主将HP (0 = Self, 1 = Enemy) ;当指右边和左边
118 : 设置主将HP ?
;119 : CreateSoldier(bLeft, x, y) retn soldierHandle
120 : SetObjectAnimate  设置物件动画
121 ：AddAttackCounter
122 : SetAttackCounterTo9999
123 : ResroteAttackCounter
;125 : 对主将造成伤害
;127 : AdjustGatherTick () ?_BATTLE_USER_INFO内的一个参数，不明。
128 ：设置BattleUserInfo->Field_54为参数2. (eg : Heal函数中，参数1为4A6878[0x02], 参数2为1)  -- 可能为设置无敌状态
129 : 返回指定方最后一个活着的小兵的handle.
12A : 得到以(x,y)为中心，(width,height)大小的矩形内，给定方的士兵的数量。
12B : 得到以(x,y)为中心，(width,height)大小的矩形内，给定方的第n个士兵的handle.
12D : 得到战场宽度  71
12E : 得到战场高度  14
12F : 设置背景亮度
130 : 得到背景亮度
131 : 设置4A6660变量为1  -- 阻止敌方施放武将技
;132 : retn 0x1aa0 ?
;133 : retn 0x3f0 ?
134 : 杀死指定的hObject
200 : Get武将名称(pGeneral)
201 : int(sin(arg1)*arg2+0.5)
202 : int(cos(arg1)*arg2+0.5)
;203 : retn 0x140 + g_nScreenStartX (screen to bigmap ?)
;204 : retn 0x0F0 + g_nScreenStartY (screen to bigmap ?)
;205 : SetScreenCameraToXY_Center(x, y)
206 : Get武将类型(0 : 武力or智力 > 90 / 1: 武力or智力>75 / 2: other)
;207 : GetMagicTitle(sequence) ?参数待确认
;209 - 211: 似乎是招降/斩首/释放操作。
;212 : retn CurrentEffect ?
300 : PlaySound
301 : PlaySound1?
303 ：Arg1 + Rand(arg2-arg1+1); 返回一个在arg1-arg2之间的随机值。
;310 - 314 : 取得ScriptLinkedObjectHandle，然后再CallSubscriptByString，区别在于参数数量不同（递增），似乎类似CALLBS但支持多于4个参数。

4A6A78:
4A6878 - 0 :
4A687C - 1 :
4A6880 - 2 : 我方主将对应Object
4A6884 - 3 : 敌方主将对应Object
4A6888 - 4 : g_nMagicAttack
4A688C - 5 : 0: left  /  1: right
4A6890 - 6 : 
4A6894 - 7 : 我方主将pGeneral结构指针
4A6898 - 8 : 敌方主将pGeneral结构指针
4A689C - 9 : 我方君主pGeneral结构指针