FixIdentifierLoader.cpp: In member function 'void Parser::loadStructTable()':
FixIdentifierLoader.cpp:93:76: error: expected ',' or ';' before ')' token
                     StructInfo* info = getStructInfoByName(member.typeName));
                                                                            ^
TreeConstruction.cpp: In member function 'int Parser::dotAndStructArray(ExpressionNode*&, int&, int)':
TreeConstruction.cpp:300:38: error: 'typeShort' is not a member of 'DataTypes'
         else if(structOrArrayType == DataTypes::typeShort || structOrArrayType == StructMember::typeUShort)
                                      ^~~~~~~~~
TreeConstruction.cpp:302:38: error: 'typeByte' is not a member of 'DataTypes'
         else if(structOrArrayType == DataTypes::typeByte || structOrArrayType == StructMember::typeUByte)
                                      ^~~~~~~~~
TreeConstruction.cpp:310:17: error: invalid conversion from 'ExpressionNode*' to 'int' [-fpermissive]
         expr(y->left, tokenPos);
              ~~~^~~~
In file included from TreeConstruction.cpp:1:0:
Parser.h:127:10: note:   initializing argument 1 of 'void Parser::expr(int&, bool)'
     void expr(int& tokenPos, bool hasResultStack);
          ^~~~
TreeConstruction.cpp:310:17: error: cannot bind rvalue '(int)y->ExpressionNode::left' to 'int&'
         expr(y->left, tokenPos);
              ~~~^~~~
TreeConstruction.cpp: In member function 'void Parser::back(ExpressionNode*&, int&)':
TreeConstruction.cpp:354:65: error: no matching function for call to 'Parser::matchMember(int&)'
         StructMember directMember = matchMember(left->resultType);
                                                                 ^
TreeConstruction.cpp:217:14: note: candidate: StructMember Parser::matchMember(int&, int)
 StructMember Parser::matchMember (int& tokenPos, int structType) {
              ^~~~~~
TreeConstruction.cpp:217:14: note:   candidate expects 2 arguments, 1 provided
